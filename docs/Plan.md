
# Загальна структура етапів

- [x] Підготовка
- [x] HTTP-сервер (TCP → HTTP)
- [ ] Контекст і сканування компонентів (BeanDefinition)
- [ ] DI: побудова черги (топосорт) і створення бінів
- [ ] Маршрутизація та параметр-біндінг (`@PathVariable`, `@RequestBody`, ін.)
- [ ] Бізнес-рівень і доступ до БД (JDBC, репозиторії, транзакції)

---

## 0) Підготовка

**Що зробити**

1. Створи порожній репозиторій Git.
2. Обери JDK 17/21.
3. Ініціалізуй проєкт (Maven/Gradle).
4. Додай `resources/application.yml` з базовими параметрами:
    * `server.port` (наприклад, 8080)
    * для БД додаси пізніше (п.5.2).
5. Створи пакети:

    * `net/` (HTTP-сервер і моделі запиту/відповіді)
    * `context/` (контейнер, сканер, DI) + `context/annotations/`
    * `web/` (роутер, анотації контролерів, обробка параметрів)
    * `db/` (DataSource, JDBC утиліти, транзакції)
    * `repo/`, `service/`, `controller/`, `entity/`, `dto/`, `util/`

**Результат**: проєкт збирається, є структура папок.

---

## 1) HTTP-сервер (TCP → HTTP)

**Мета**: приймати TCP-з’єднання, читати HTTP-запит, повертати HTTP-відповідь.

**Що зробити, в якому порядку**

1. Створи моделі:

    * `HttpRequest` (поля: method, path, queryParams, headers, bodyBytes)
    * `HttpResponse` (поля: status, headers, bodyBytes; + зручні фабрики типу `okJson(...)`, `of(status, ...)`)
2. Реалізуй `HttpParser`:
3.
    * парсинг стартового рядка: метод, шлях, версія
    * парсинг заголовків у `Map<String,String>`
    * **тіло**: підтримай **лише** `Content-Length` (для простоти); зчитуй рівно стільки байтів
    * **не** перетворюй тіло в об’єкт тут — збережи як `byte[]`
3. Реалізуй `HttpServer`:
4.
    * відкриття `ServerSocket(port)`; нескінченний цикл `accept()`
    * для кожного з’єднання: зчитати запит → передати в **Router** (пізніше, тимчасово можна віддати stub-відповідь)
    * завжди закривати сокет після відповіді (без keep-alive на першому кроці)
4. Додай простий логер (у `util/Log`) для дебагу.

**Перевірка**

* `curl -i http://localhost:8080/ping` → 200 OK (поки можна повернути статичний JSON/stub).

---

## 2) Контекст і сканування компонентів (BeanDefinition)

**Мета**: зібрати метадані бінів, але ще **не створювати** всі інстанси.

**Що зробити, в якому порядку**

1. Оголоси анотації в `context/annotations/`:

    * рівень класу: `@Component`, `@Service`, `@Repository`, `@Controller`/`@RestController`, `@Configuration`
    * рівень методу: `@Bean`
    * DI-допоміжні: `@Inject`, `@Qualifier("...")`, (опц.) `@PostConstruct`
2. Спроєктуй `BeanDefinition` (метадані):

    * `name`, `type`, `scope` (спершу тільки `SINGLETON`)
    * **джерело**: CLASS або FACTORY_METHOD (для `@Bean`)
    * `ctor` (обраний конструктор) + `ctorParamTypes`
    * (опц.) `qualifier`, `primary`
3. Створи `BeanRegistry`:

    * реєстри: за **іменем** і за **типом**
    * колекція всіх `BeanDefinition`
    * мапа готових сінглтонів (поки порожня)
4. Зроби `Scanner`:

    * **вхід**: список базових пакетів (наприклад, `com.app`)
    * знаходження класів у пакетах (через classpath resources)
    * **для класів** з відповідними анотаціями: обрати конструктор:

        * якщо є `@Inject` — він пріоритетний
        * інакше — конструктор з **максимальною кількістю параметрів**
    * створити `BeanDefinition` типу CLASS
    * **для класів `@Configuration`**: знайти методи `@Bean`, створити `BeanDefinition` типу FACTORY_METHOD (врахуй тип і параметри методу)
    * зареєструвати всі дефінішини у `BeanRegistry`
5. Логування: скільки знайшли бінів кожного типу; перелік імен.

**Перевірка**

* логи показують **усі** знайдені `BeanDefinition` і **жодних** конфліктів імен.

---

## 3) DI: побудова черги і створення бінів

**Мета**: з `BeanDefinition` побудувати граф залежностей, зробити топосорт, створити SINGLETON-и.

**Що зробити, в якому порядку**

1. Резолв кандидатів за типом (на етапі графа):

    * для кожного параметра конструктора/bean-методу знайди **рівно 1** кандидат типу
    * якщо >1 → вимагай `@Qualifier` або `@Primary` → інакше **помилка конфігурації**
    * якщо 0 → **UnsatisfiedDependency**
2. Побудуй **граф залежностей**:

    * вузол = ім’я біна
    * ребра: `beanName -> dependencyBeanName`
3. Виконай **топологічне сортування**:

    * алгоритм Kahn/DFS; якщо граф має цикл → помилка **Cyclic dependency**
    * результат: **черга** створення `order = [ ... ]`
4. Реалізуй `BeanFactory`:

    * іди у порядку `order`
    * для кожного біна:

        * підготуй аргументи конструктора/bean-методу з **вже створених** залежностей
        * створи інстанс
        * поклади у `singletons`, а також у `beanMap`/`nameMap` (для швидкого отримання)
        * (опц.) виклич `@PostConstruct`
5. Інтегруй у `ApplicationContext`:

    * `scan()` → `resolve&toposort()` → `instantiateSingletons()`

**Перевірка**

* лог порядку створення бінів узгоджений; у циклі — чітка помилка з трасою
* можна отримати будь-який сервіс з контексту за типом/іменем

---

## 4) Маршрутизація та параметр-біндінг

**Мета**: зіставити HTTP-запит із методом контролера та підготувати аргументи.

**Що зробити, в якому порядку**

1. Оголоси анотації в `web/annotations/`:

    * клас: `@RestController`, `@RequestMapping(basePath)`
    * метод: `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` (або універсальний `@RequestMapping(method, path)`)
    * параметри методу: `@PathVariable("name")`, `@RequestParam("name")`, `@RequestBody`, `@Header("Name")`
2. Створи `Route`:

    * зберігає `method`, `template`, скомпільований `regex`, порядок `pathVarNames`
    * приклад шаблону: `/users/{id}` → `^/users/([^/]+)$` + список `["id"]`
3. Створи `Handler`:

    * посилання на `bean` (контролер), `method`
    * список `ParamExtractor` (по одному на кожен параметр методу)
4. Зроби `HandlerBuilder`:

    * читає анотації параметрів методу контролера
    * додає відповідні екстрактори:

        * `PathVariable`: бере з карти pathVars + конвертує у потрібний тип
        * `RequestParam`: з `queryParams` + конвертація типів, обов’язковість/дефолти
        * `RequestBody`: перевіряє `Content-Type` = `application/json` → десеріалізує у DTO (через `util/Json`)
        * `Header`: зчитує із заголовків
    * у випадку помилок формату/типів → сигналізує 400
5. Реєстратор маршрутів (`RouteRegistrar`):

    * після побудови контексту пройди всi біни, знайди `@RestController`
    * обчисли `basePath` з класу (`@RequestMapping`) і склади з методом
    * для кожного HTTP-методу створюй `Route`, `Handler` (через `HandlerBuilder`), зареєструй у `Router`
6. `Router`:

    * `Map<method, List<RouteEntry>>`
    * по запиту: знаходить перший збіг за regex → збирає pathVars → викликає `handler`
    * результат методу:

        * якщо POJO → серіалізація в JSON (200)
        * якщо `ResponseEntity` → використовує статус/заголовки/тіло з нього
    * перетворює винятки в 4xx/5xx (або делегує у глобальний обробник, див. п.6)

**Перевірка**

* `GET /api/hello?name=...` → 200 JSON
* `GET /api/users/123` із нечисловим `id` → 400
* `POST /api/users` без валідного JSON → 400

---

## 5) Бізнес-рівень і доступ до БД (JDBC, репозиторії, транзакції)

**Мета**: CRUD через простий JDBC шар, репозиторії, сервісну логіку і транзакції.

**Що зробити, в якому порядку**

1. **Моделі та DTO**:

    * у `entity/` опиши сутності (наприклад, `User` з полями `id`, `name`, `email`)
    * у `dto/` опиши DTO для запитів/відповідей
    * визнач правила мапінгу `camelCase` ↔ `snake_case` або використовуй анотації `@Table`, `@Column`, `@Id`
2. **JDBC-конфіг**:

    * у `application.yml` додай `db.url`, `db.user`, `db.pass`, `db.driver`
    * `DataSourceFactory` читає ці значення і повертає `DataSource` (спершу на `DriverManager`)
    * додай `resources/schema.sql` для створення таблиць; виконай при старті
    * **для деву** обери H2 in-memory; **для інтеграції** — Postgres
3. **Репозиторії**:

    * контракт `CrudRepository<T,ID>`: `findById`, `findAll`, `save`, `deleteById`
    * політика `save`: insert якщо `id==null` або запис відсутній; update — інакше
    * утиліта `Jdbc`: `query`, `queryOne`, `update`, `insertAndReturnKey`
    * `RowMapper<T>` або рефлексійний `EntityMapper` для `ResultSet → Entity` (кешуй метадані класів)
4. **Сервісний шар**:

    * `UserService`: методи `create`, `get`, `list`, `update`, `delete`
    * валідація DTO (обов’язкові поля, формат email, унікальність — на рівні сервісу чи БД)
    * трансляція доменних винятків (`NotFound`, `Duplicate`) для HTTP (через п.6)
5. **Транзакції**:

    * **мінімально**: автокоміт true — якщо кожна операція одиночна
    * **базово**: `TransactionManager` з `ThreadLocal<Connection>`:

        * `begin()` → `autoCommit=false`, наприкінці `commit()` або `rollback()` у `finally`
        * **межа транзакції** — сервісний метод (наприклад, `create` робить кілька SQL-операцій)
        * помилки → `rollback`, логування
